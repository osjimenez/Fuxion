using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Text.Json.Serialization;
using Fuxion.Text.Json.Serialization;

namespace Fuxion;

public class Response
	: Response<object?>
{
	internal Response(
		bool isSuccess,
		object? payload,
		string? message = null,
		object? type = null,
		Exception? exception = null)
		: base(isSuccess, payload, message, type, exception) { }
	public Response(
		bool isSuccess,
		string? message = null,
		object? type = null,
		Exception? exception = null)
		: this(isSuccess, null, message, type, exception) { }
	public bool TryGetPayload<TPayload>([NotNullWhen(true)] out TPayload payload)
	{
		if (Payload is TPayload tp)
		{
			payload = tp;
			return true;
		}
		payload = default!;
		return false;
	}
	public static IResponseFactory Get => new ResponseFactory();
}

public class Response<TPayload>(
	bool isSuccess,
	TPayload payload,
	string? message = null,
	object? type = null,
	Exception? exception = null)
{
	[MemberNotNullWhen(true, nameof(Payload))]
	public bool IsSuccess { get; } = isSuccess;

	[JsonIgnore]
	[MemberNotNullWhen(false, nameof(Payload))]
	public bool IsError => !IsSuccess;

	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	public string? Message { get; } = message;

	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
	public TPayload? Payload { get; } = payload;

	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	public object? ErrorType { get; } = type;

	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
	[JsonConverter(typeof(ExceptionConverter))]
	public Exception? Exception { get; } = exception;

	[JsonExtensionData]
	public IDictionary<string, object?> Extensions { get; init; } = new Dictionary<string, object?>(StringComparer.Ordinal);

	public static implicit operator TPayload?(Response<TPayload> response) => response.Payload;
	public static implicit operator Response<TPayload>(TPayload payload) => new(true, payload);

	public static implicit operator Response(Response<TPayload> response)
		=> new(
			response.IsSuccess,
			response.Payload,
			response.Message,
			response.ErrorType,
			response.Exception)
		{
			Extensions = response.Extensions
		};
	public static implicit operator Response<TPayload>(Response response) => new(
		response.IsSuccess,
		response.Payload is TPayload payload ? payload : default!,
		response.Message,
		response.ErrorType,
		response.Exception)
	{
		Extensions = response.Extensions
	};
}

// https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/ProblemDetails/ProblemDetails.cs
/// <summary>
/// A machine-readable format for specifying errors in HTTP API responses based on <see href="https://tools.ietf.org/html/rfc7807"/>.
/// </summary>
public class ResponseProblemDetails
{
	/// <summary>
	/// A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
	/// dereferenced, it provide human-readable documentation for the problem type
	/// (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be
	/// "about:blank".
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-5)]
	[JsonPropertyName("type")]
	public string? Type { get; set; }

	/// <summary>
	/// A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence
	/// of the problem, except for purposes of localization(e.g., using proactive content negotiation;
	/// see[RFC7231], Section 3.4).
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-4)]
	[JsonPropertyName("title")]
	public string? Title { get; set; }

	/// <summary>
	/// The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-3)]
	[JsonPropertyName("status")]
	public int? Status { get; set; }

	/// <summary>
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-2)]
	[JsonPropertyName("detail")]
	public string? Detail { get; set; }

	/// <summary>
	/// A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-1)]
	[JsonPropertyName("instance")]
	public string? Instance { get; set; }

	/// <summary>
	/// Gets the <see cref="IDictionary{TKey, TValue}"/> for extension members.
	/// <para>
	/// Problem type definitions MAY extend the problem details object with additional members. Extension members appear in the same namespace as
	/// other members of a problem type.
	/// </para>
	/// </summary>
	/// <remarks>
	/// The round-tripping behavior for <see cref="Extensions"/> is determined by the implementation of the Input \ Output formatters.
	/// In particular, complex types or collection types may not round-trip to the original type when using the built-in JSON or XML formatters.
	/// </remarks>
	[JsonExtensionData]
	public IDictionary<string, object?> Extensions { get; set; } = new Dictionary<string, object?>(StringComparer.Ordinal);
}
public static class ResponseExtensions
{
	public static Response CombineResponses(this IEnumerable<Response<object?>> responses, string? message = null)
	{
		if (responses.Any(r => r.IsError))
			return new Response<IEnumerable<Response<object?>>>(false, responses.Where(r => r.IsError), message);
		return new Response<IEnumerable<Response<object?>>>(true, responses, message);
	}

	// Response.Get helpers
	public static Response SuccessMessage(this IResponseFactory me, string message)
		=> new(true, message);
	public static Response SuccessMessage(this IResponseFactory me, string? message = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> new(true, message)
		{
			Extensions = extensions.ToDictionary(t => t.Property, t => t.Value)
		};
	public static Response<TPayload> Success<TPayload>(this IResponseFactory me, TPayload payload, string? message = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> new(true, payload, message)
		{
			Extensions = extensions.ToDictionary(t => t.Property, t => t.Value)
		};

	public static Response Error(this IResponseFactory me, string message, object? type = null, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> new(false, message, type, exception)
		{
			Extensions = extensions.ToDictionary(t => t.Property, t => t.Value)
		};
	public static Response<TPayload> Error<TPayload>(this IResponseFactory me, string message, TPayload payload, object? type = null, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> new(false, payload, message, type, exception)
		{
			Extensions = extensions.ToDictionary(t => t.Property, t => t.Value)
		};
	public static bool IsErrorType<TPayload>(this Response<TPayload> res, object type)
		=> res.ErrorType?.Equals(type) == true;

	public static Response Exception(this IResponseFactory me, Exception exception, string? message = null)
		=> new(false, message ?? $"{exception.GetType().Name}: {exception.Message}", exception: exception);

	// Specific error types
	public static Response NotFound(this IErrorResponseFactory me, string message, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.NotFound, exception, extensions);
	public static Response<TPayload> NotFound<TPayload>(this IErrorResponseFactory me, string message, TPayload payload, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.NotFound, exception, extensions);
	public static bool IsNotFound<TPayload>(this Response<TPayload> res)
		=> res.IsErrorType(ErrorType.NotFound);

	public static Response PermissionDenied(this IErrorResponseFactory me, string message, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.PermissionDenied, exception, extensions);
	public static Response<TPayload> PermissionDenied<TPayload>(this IErrorResponseFactory me, string message, TPayload payload, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.PermissionDenied, exception, extensions);
	public static bool IsPermissionDenied<TPayload>(this Response<TPayload> res)
		=> res.IsErrorType(ErrorType.PermissionDenied);

	public static Response InvalidData(this IErrorResponseFactory me, string message, Exception? exception = null, params List<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.InvalidData, exception, extensions);
	public static Response<TPayload> InvalidData<TPayload>(this IErrorResponseFactory me, string message, TPayload payload, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.InvalidData, exception, extensions);
	public static bool IsInvalidData<TPayload>(this Response<TPayload> res)
		=> res.IsErrorType(ErrorType.InvalidData);

	public static Response Conflict(this IErrorResponseFactory me, string message, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.Conflict, exception, extensions);
	public static Response<TPayload> Conflict<TPayload>(this IErrorResponseFactory me, string message, TPayload payload, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.Conflict, exception, extensions);
	public static bool IsConflict<TPayload>(this Response<TPayload> res)
		=> res.IsErrorType(ErrorType.Conflict);

	public static Response Critical(this IErrorResponseFactory me, string message, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.Critical, exception, extensions);
	public static Response<TPayload> Critical<TPayload>(this IErrorResponseFactory me, string message, TPayload payload, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.Critical, exception, extensions);
	public static bool IsCritical<TPayload>(this Response<TPayload> res)
		=> res.IsErrorType(ErrorType.Critical);

	public static Response NotSupported(this IErrorResponseFactory me, string message, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.NotSupported, exception, extensions);
	public static Response<TPayload> NotSupported<TPayload>(this IErrorResponseFactory me, string message, TPayload payload, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.NotSupported, exception, extensions);
	public static bool IsNotSupported<TPayload>(this Response<TPayload> res)
		=> res.IsErrorType(ErrorType.NotSupported);

	public static Response Unavailable(this IErrorResponseFactory me, string message, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.Unavailable, exception, extensions);
	public static Response<TPayload> Unavailable<TPayload>(this IErrorResponseFactory me, string message, TPayload payload, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.Unavailable, exception, extensions);
	public static bool IsUnavailable<TPayload>(this Response<TPayload> res)
		=> res.IsErrorType(ErrorType.Unavailable);

	public static Response Timeout(this IErrorResponseFactory me, string message, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.Timeout, exception, extensions);
	public static Response<TPayload> Timeout<TPayload>(this IErrorResponseFactory me, string message, TPayload payload, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.Timeout, exception, extensions);
	public static bool IsTimeout<TPayload>(this Response<TPayload> res)
		=> res.IsErrorType(ErrorType.Timeout);
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum ErrorType
{
	NotFound,
	PermissionDenied,
	InvalidData,
	Conflict,
	Critical,
	NotSupported,
	Unavailable,
	Timeout
}

public interface IResponseFactory
{
	IErrorResponseFactory Error { get; }
}

internal class ResponseFactory : IResponseFactory
{
	public ResponseFactory()
	{
		Error = new ErrorResponseFactory(this);
	}
	public IErrorResponseFactory Error { get; }
}

public interface IErrorResponseFactory
{
	internal IResponseFactory Factory { get; }
}
internal class ErrorResponseFactory(IResponseFactory factory) : IErrorResponseFactory
{
	public IResponseFactory Factory { get; } = factory;
}