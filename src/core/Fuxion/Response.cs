using System;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;
using Fuxion.Text.Json.Serialization;

namespace Fuxion;

[JsonConverter(typeof(InterfaceSerializerConverter<IResponse>))]
public interface IResponse
{
	bool IsSuccess { get; }
	bool IsError { get; }
	string? Message { get; }
	object? ErrorType { get; }
	Exception? Exception { get; }
	IDictionary<string, object?> Extensions { get; }
	IResponse<T> AsPayload<T>();
}

public interface IResponse<out TPayload> : IResponse
{
#if !NET472 && !NETSTANDARD2_0
	[MemberNotNullWhen(true, nameof(Payload))]
	new bool IsSuccess => (this as IResponse).IsSuccess;
	[MemberNotNullWhen(false, nameof(Payload))]
	new bool IsError => (this as IResponse).IsError;
#else
	[MemberNotNullWhen(true, nameof(Payload))]
	new bool IsSuccess { get; }
	[MemberNotNullWhen(false, nameof(Payload))]
	new bool IsError { get; }
#endif
	TPayload? Payload { get; }
}

public class Response(bool isSuccess, string? message = null, object? type = null, Exception? exception = null) : IResponse
{
	public static IResponseFactory Get => new ResponseFactory();

	public bool IsSuccess { get; protected init; } = isSuccess;
	[JsonIgnore]
	public bool IsError => !IsSuccess;
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	public string? Message { get; init; } = message;

	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	public object? ErrorType { get; init; } = type;
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
	[JsonConverter(typeof(ExceptionConverter))]
	public Exception? Exception { get; init; } = exception;
	[JsonExtensionData]
	public IDictionary<string, object?> Extensions { get; init; } = new Dictionary<string, object?>(StringComparer.Ordinal);

	public IResponse<T> AsPayload<T>()
	{
		if (this is IResponse<T> r) return r;
		if (IsSuccess) throw new InvalidOperationException("Can't convert a success response to a different payload type.");
		return new Response<T>(IsSuccess, default!, Message, ErrorType, Exception)
		{
			Extensions = Extensions
		};
	}
	// Conversores implÃ­citos con bool
	public static implicit operator bool(Response response) => response.IsSuccess;
	//public static implicit operator Response(bool isSuccess) => new(isSuccess);
}

public class Response<TPayload>(bool isSuccess, TPayload payload, string? message = null, object? type = null, Exception? exception = null)
	: Response(isSuccess, message, type, exception), IResponse<TPayload>
{
	[MemberNotNullWhen(true, nameof(Payload))]
	public new bool IsSuccess
	{
		get => base.IsSuccess;
		protected init => base.IsSuccess = value;
	}
	[MemberNotNullWhen(false, nameof(Payload))]
	[JsonIgnore]
	public new bool IsError => base.IsError;

	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
	public TPayload? Payload
	{
		get;
		init
			=> field = value?.GetType()
				.IsSubclassOfRawGeneric(typeof(Response<>)) ?? false
				? throw new ArgumentException($"Payload is '{value.GetType().GetSignature()}' type, but can't be derived from '{typeof(Response<>).GetSignature()}' to avoid nested responses.",
					nameof(Payload))
				: value;
	} = payload;
	public static implicit operator TPayload?(Response<TPayload> response) => response.Payload;
	public static implicit operator Response<TPayload>(TPayload payload) => new(true, payload);
}

// https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/ProblemDetails/ProblemDetails.cs
/// <summary>
/// A machine-readable format for specifying errors in HTTP API responses based on <see href="https://tools.ietf.org/html/rfc7807"/>.
/// </summary>
public class ResponseProblemDetails
{
	/// <summary>
	/// A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
	/// dereferenced, it provide human-readable documentation for the problem type
	/// (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be
	/// "about:blank".
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-5)]
	[JsonPropertyName("type")]
	public string? Type { get; set; }
	/// <summary>
	/// A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence
	/// of the problem, except for purposes of localization(e.g., using proactive content negotiation;
	/// see[RFC7231], Section 3.4).
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-4)]
	[JsonPropertyName("title")]
	public string? Title { get; set; }
	/// <summary>
	/// The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-3)]
	[JsonPropertyName("status")]
	public int? Status { get; set; }
	/// <summary>
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-2)]
	[JsonPropertyName("detail")]
	public string? Detail { get; set; }
	/// <summary>
	/// A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-1)]
	[JsonPropertyName("instance")]
	public string? Instance { get; set; }
	/// <summary>
	/// Gets the <see cref="IDictionary{TKey, TValue}"/> for extension members.
	/// <para>
	/// Problem type definitions MAY extend the problem details object with additional members. Extension members appear in the same namespace as
	/// other members of a problem type.
	/// </para>
	/// </summary>
	/// <remarks>
	/// The round-tripping behavior for <see cref="Extensions"/> is determined by the implementation of the Input \ Output formatters.
	/// In particular, complex types or collection types may not round-trip to the original type when using the built-in JSON or XML formatters.
	/// </remarks>
	[JsonExtensionData]
	public IDictionary<string, object?> Extensions { get; set; } = new Dictionary<string, object?>(StringComparer.Ordinal);
}

public static class ResponseExtensions
{
	public static IResponse CombineResponses(this IEnumerable<IResponse> responses, string? message = null)
	{
		if (responses.Any(r => r.IsError)) return new Response<IEnumerable<IResponse>>(false, responses.Where(r => r.IsError), message);
		return new Response<IEnumerable<IResponse>>(true, responses, message);
	}

	// Response.Get helpers
	public static IResponse Success(this IResponseFactory me, params IEnumerable<(string Property, object? Value)> extensions)
		=> new Response(true)
		{
			Extensions = extensions.ToDictionary(t => t.Property, t => t.Value)
		};
	public static IResponse SuccessMessage(this IResponseFactory me, string message, params IEnumerable<(string Property, object? Value)> extensions)
		=> new Response(true, message)
		{
			Extensions = extensions.ToDictionary(t => t.Property, t => t.Value)
		};
	public static IResponse<TPayload> SuccessPayload<TPayload>(this IResponseFactory me, TPayload payload, string? message = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> new Response<TPayload>(true, payload, message)
		{
			Extensions = extensions.ToDictionary(t => t.Property, t => t.Value)
		};
	public static IResponse Error(this IResponseFactory me, string message, object? type = null, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> new Response(false, message, type, exception)
		{
			Extensions = extensions.ToDictionary(t => t.Property, t => t.Value)
		};
	public static IResponse<TPayload> Error<TPayload>(
		this IResponseFactory me,
		string message,
		TPayload payload,
		object? type = null,
		Exception? exception = null,
		params IEnumerable<(string Property, object? Value)> extensions)
		=> new Response<TPayload>(false, payload, message, type, exception)
		{
			Extensions = extensions.ToDictionary(t => t.Property, t => t.Value)
		};
	public static bool IsErrorType(this IResponse res, object type) => res.ErrorType?.Equals(type) == true;
	public static IResponse Exception(this IResponseFactory me, Exception exception, string? message = null)
		=> new Response(false, message ?? $"{exception.GetType().Name}: {exception.Message}", exception: exception);

	// Specific error types
	public static IResponse NotFound(this IErrorResponseFactory me, string message, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.NotFound, exception, extensions);
	public static IResponse<TPayload> NotFound<TPayload>(
		this IErrorResponseFactory me,
		string message,
		TPayload payload,
		Exception? exception = null,
		params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.NotFound, exception, extensions);
	public static bool IsNotFound(this IResponse res) => res.IsErrorType(ErrorType.NotFound);
	
	public static IResponse PermissionDenied(this IErrorResponseFactory me, string message, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.PermissionDenied, exception, extensions);
	public static IResponse<TPayload> PermissionDenied<TPayload>(
		this IErrorResponseFactory me,
		string message,
		TPayload payload,
		Exception? exception = null,
		params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.PermissionDenied, exception, extensions);
	public static bool IsPermissionDenied(this IResponse res) => res.IsErrorType(ErrorType.PermissionDenied);
	public static IResponse InvalidData(this IErrorResponseFactory me, string message, Exception? exception = null, params List<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.InvalidData, exception, extensions);
	public static IResponse<TPayload> InvalidData<TPayload>(
		this IErrorResponseFactory me,
		string message,
		TPayload payload,
		Exception? exception = null,
		params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.InvalidData, exception, extensions);
	public static bool IsInvalidData(this IResponse res) => res.IsErrorType(ErrorType.InvalidData);
	public static IResponse Conflict(this IErrorResponseFactory me, string message, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.Conflict, exception, extensions);
	public static IResponse<TPayload> Conflict<TPayload>(
		this IErrorResponseFactory me,
		string message,
		TPayload payload,
		Exception? exception = null,
		params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.Conflict, exception, extensions);
	public static bool IsConflict(this IResponse res) => res.IsErrorType(ErrorType.Conflict);
	public static IResponse Critical(this IErrorResponseFactory me, string message, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.Critical, exception, extensions);
	public static IResponse<TPayload> Critical<TPayload>(
		this IErrorResponseFactory me,
		string message,
		TPayload payload,
		Exception? exception = null,
		params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.Critical, exception, extensions);
	public static bool IsCritical(this IResponse res) => res.IsErrorType(ErrorType.Critical);
	public static IResponse NotSupported(this IErrorResponseFactory me, string message, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.NotSupported, exception, extensions);
	public static IResponse<TPayload> NotSupported<TPayload>(
		this IErrorResponseFactory me,
		string message,
		TPayload payload,
		Exception? exception = null,
		params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.NotSupported, exception, extensions);
	public static bool IsNotSupported(this IResponse res) => res.IsErrorType(ErrorType.NotSupported);
	public static IResponse Unavailable(this IErrorResponseFactory me, string message, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.Unavailable, exception, extensions);
	public static IResponse<TPayload> Unavailable<TPayload>(
		this IErrorResponseFactory me,
		string message,
		TPayload payload,
		Exception? exception = null,
		params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.Unavailable, exception, extensions);
	public static bool IsUnavailable(this IResponse res) => res.IsErrorType(ErrorType.Unavailable);
	public static IResponse Timeout(this IErrorResponseFactory me, string message, Exception? exception = null, params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, ErrorType.Timeout, exception, extensions);
	public static IResponse<TPayload> Timeout<TPayload>(
		this IErrorResponseFactory me,
		string message,
		TPayload payload,
		Exception? exception = null,
		params IEnumerable<(string Property, object? Value)> extensions)
		=> me.Factory.Error(message, payload, ErrorType.Timeout, exception, extensions);
	public static bool IsTimeout(this IResponse res) => res.IsErrorType(ErrorType.Timeout);
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum ErrorType
{
	NotFound,
	PermissionDenied,
	InvalidData,
	Conflict,
	Critical,
	NotSupported,
	Unavailable,
	Timeout
}

public interface IResponseFactory
{
	IErrorResponseFactory Error { get; }
}

internal class ResponseFactory : IResponseFactory
{
	public ResponseFactory() => Error = new ErrorResponseFactory(this);
	public IErrorResponseFactory Error { get; }
}

public interface IErrorResponseFactory
{
	internal IResponseFactory Factory { get; }
}

internal class ErrorResponseFactory(IResponseFactory factory) : IErrorResponseFactory
{
	public IResponseFactory Factory { get; } = factory;
}