using System;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;
using Fuxion.Text.Json.Serialization;

namespace Fuxion;

[JsonConverter(typeof(InterfaceSerializerConverter<IResponse>))]
public interface IResponse
{
	bool IsSuccess { get; }
	bool IsError { get; }
	string? Message { get; }
	object? ErrorType { get; }
	Exception? Exception { get; }
	IDictionary<string, object?> Extensions { get; }
	//IResponse<T> AsPayload<T>();
}

public interface IResponse<out TPayload> : IResponse
{
#if !NET472 && !NETSTANDARD2_0
	[MemberNotNullWhen(true, nameof(Payload))]
	new bool IsSuccess => (this as IResponse).IsSuccess;
	[MemberNotNullWhen(false, nameof(Payload))]
	new bool IsError => (this as IResponse).IsError;
#else
	[MemberNotNullWhen(true, nameof(Payload))]
	new bool IsSuccess { get; }
	[MemberNotNullWhen(false, nameof(Payload))]
	new bool IsError { get; }
#endif
	TPayload? Payload { get; }
}

public class Response(bool isSuccess, string? message = null, object? type = null, Exception? exception = null) : IResponse
{
	public bool IsSuccess { get; protected init; } = isSuccess;
	[JsonIgnore]
	public bool IsError => !IsSuccess;
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	public string? Message { get; init; } = message;

	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	public object? ErrorType { get; init; } = type;
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
	[JsonConverter(typeof(ExceptionConverter))]
	public Exception? Exception { get; init; } = exception;
	[JsonExtensionData]
	public IDictionary<string, object?> Extensions { get; init; } = new Dictionary<string, object?>(StringComparer.Ordinal);

	//public IResponse<T> AsPayload<T>()
	//{
	//	if (this is IResponse<T> r) return r;
	//	if (IsSuccess) throw new InvalidOperationException("Can't convert a success response to a different payload type.");
	//	return new Response<T>(IsSuccess, default!, Message, ErrorType, Exception)
	//	{
	//		Extensions = Extensions
	//	};
	//}
	// Conversores implÃ­citos con bool
	public static implicit operator bool(Response response) => response.IsSuccess;
	//public static implicit operator Response(bool isSuccess) => new(isSuccess);
}

public class Response<TPayload>(bool isSuccess, TPayload payload, string? message = null, object? type = null, Exception? exception = null)
	: Response(isSuccess, message, type, exception), IResponse<TPayload>
{
	[MemberNotNullWhen(true, nameof(Payload))]
	public new bool IsSuccess
	{
		get => base.IsSuccess;
		protected init => base.IsSuccess = value;
	}
	[MemberNotNullWhen(false, nameof(Payload))]
	[JsonIgnore]
	public new bool IsError => base.IsError;

	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
	public TPayload? Payload
	{
		get;
		init
			=> field = value?.GetType()
				.IsSubclassOfRawGeneric(typeof(Response<>)) ?? false
				? throw new ArgumentException($"Payload is '{value.GetType().GetSignature()}' type, but can't be derived from '{typeof(Response<>).GetSignature()}' to avoid nested responses.",
					nameof(Payload))
				: value;
	} = payload;
	public static implicit operator TPayload?(Response<TPayload> response) => response.Payload;
	public static implicit operator Response<TPayload>(TPayload payload) => new(true, payload);
}

// https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/ProblemDetails/ProblemDetails.cs
/// <summary>
/// A machine-readable format for specifying errors in HTTP API responses based on <see href="https://tools.ietf.org/html/rfc7807"/>.
/// </summary>
public class ResponseProblemDetails
{
	/// <summary>
	/// A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
	/// dereferenced, it provide human-readable documentation for the problem type
	/// (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be
	/// "about:blank".
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-5)]
	[JsonPropertyName("type")]
	public string? Type { get; set; }
	/// <summary>
	/// A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence
	/// of the problem, except for purposes of localization(e.g., using proactive content negotiation;
	/// see[RFC7231], Section 3.4).
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-4)]
	[JsonPropertyName("title")]
	public string? Title { get; set; }
	/// <summary>
	/// The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-3)]
	[JsonPropertyName("status")]
	public int? Status { get; set; }
	/// <summary>
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-2)]
	[JsonPropertyName("detail")]
	public string? Detail { get; set; }
	/// <summary>
	/// A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-1)]
	[JsonPropertyName("instance")]
	public string? Instance { get; set; }
	/// <summary>
	/// Gets the <see cref="IDictionary{TKey, TValue}"/> for extension members.
	/// <para>
	/// Problem type definitions MAY extend the problem details object with additional members. Extension members appear in the same namespace as
	/// other members of a problem type.
	/// </para>
	/// </summary>
	/// <remarks>
	/// The round-tripping behavior for <see cref="Extensions"/> is determined by the implementation of the Input \ Output formatters.
	/// In particular, complex types or collection types may not round-trip to the original type when using the built-in JSON or XML formatters.
	/// </remarks>
	[JsonExtensionData]
	public IDictionary<string, object?> Extensions { get; set; } = new Dictionary<string, object?>(StringComparer.Ordinal);
}

public static class ResponseExtensions
{
	extension(IResponse me)
	{
		public IResponse<T> AsPayload<T>()
		{
			if (me is IResponse<T> r) return r;
			if (me.IsSuccess) throw new InvalidOperationException("Can't convert a success response to a different payload type.");
			return new Response<T>(me.IsSuccess, default!, me.Message, me.ErrorType, me.Exception)
			{
				Extensions = me.Extensions
			};
		}
	}
	extension(IEnumerable<IResponse> me)
	{
		public IResponse CombineResponses(string? message = null)
		{
			if (me.Any(r => r.IsError)) return new Response<IEnumerable<IResponse>>(false, me.Where(r => r.IsError), message);
			return new Response<IEnumerable<IResponse>>(true, me, message);
		}
	}
	extension(Response me)
	{
		
		public static IResponse Success(IEnumerable<(string Property, object? Value)>? extensions = null)
			=> new Response(true)
			{
				Extensions = extensions?.ToDictionary(t => t.Property, t => t.Value) ?? []
			};
		public static IResponse SuccessMessage(string message, IEnumerable<(string Property, object? Value)>? extensions = null)
		=> new Response(true, message)
		{
			Extensions = extensions?.ToDictionary(t => t.Property, t => t.Value) ?? []
		};
		public static IResponse<TPayload> SuccessPayload<TPayload>(TPayload payload, string? message = null, IEnumerable<(string Property, object? Value)>? extensions = null)
			=> new Response<TPayload>(true, payload, message)
			{
				Extensions = extensions?.ToDictionary(t => t.Property, t => t.Value) ?? []
			};
		public static IResponse ErrorMessage(string message, object? type = null, Exception? exception = null, IEnumerable<(string Property, object? Value)>? extensions = null)
			=> new Response(false, message, type, exception)
			{
				Extensions = extensions?.ToDictionary(t => t.Property, t => t.Value) ?? []
			};
		public static IResponse<TPayload> ErrorPayload<TPayload>(
			TPayload payload,
			string? message = null,
			object? type = null,
			Exception? exception = null,
			IEnumerable<(string Property, object? Value)>? extensions = null)
			=> new Response<TPayload>(false, payload, message, type, exception)
			{
				Extensions = extensions?.ToDictionary(t => t.Property, t => t.Value) ?? []
			};
		
		public static IResponse Exception(Exception exception, string? message = null)
			=> new Response(false, message ?? $"{exception.GetType().Name}: {exception.Message}", exception: exception);

		// Not found
		public static IResponse NotFound(string message, Exception? exception = null, IEnumerable<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorMessage(message, ErrorType.NotFound, exception, extensions);
		public static IResponse<TPayload> NotFound<TPayload>(
			string message,
			TPayload payload,
			Exception? exception = null,
			IEnumerable<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorPayload<TPayload>(payload, message, ErrorType.NotFound, exception, extensions);
		
		// Permission denied
		public static IResponse PermissionDenied(string message, Exception? exception = null, IEnumerable<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorMessage(message, ErrorType.PermissionDenied, exception, extensions);
		public static IResponse<TPayload> PermissionDenied<TPayload>(
			string message,
			TPayload payload,
			Exception? exception = null,
			IEnumerable<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorPayload<TPayload>(payload, message, ErrorType.PermissionDenied, exception, extensions);
		
		// Invalid data
		public static IResponse InvalidData(string message, Exception? exception = null, List<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorMessage(message, ErrorType.InvalidData, exception, extensions);
		public static IResponse<TPayload> InvalidData<TPayload>(
			string message,
			TPayload payload,
			Exception? exception = null,
			IEnumerable<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorPayload<TPayload>(payload, message, ErrorType.InvalidData, exception, extensions);
		
		// Conflict
		public static IResponse Conflict(string message, Exception? exception = null, IEnumerable<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorMessage(message, ErrorType.Conflict, exception, extensions);
		public static IResponse<TPayload> Conflict<TPayload>(
			string message,
			TPayload payload,
			Exception? exception = null,
			IEnumerable<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorPayload<TPayload>(payload, message, ErrorType.Conflict, exception, extensions);
		
		// Critical
		public static IResponse Critical(string message, Exception? exception = null, IEnumerable<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorMessage(message, ErrorType.Critical, exception, extensions);
		public static IResponse<TPayload> Critical<TPayload>(
			string message,
			TPayload payload,
			Exception? exception = null,
			IEnumerable<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorPayload<TPayload>(payload, message, ErrorType.Critical, exception, extensions);
		
		// Not supported
		public static IResponse NotSupported(string message, Exception? exception = null, IEnumerable<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorMessage(message, ErrorType.NotSupported, exception, extensions);
		public static IResponse<TPayload> NotSupported<TPayload>(
			string message,
			TPayload payload,
			Exception? exception = null,
			IEnumerable<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorPayload<TPayload>(payload, message, ErrorType.NotSupported, exception, extensions);
		
		// Unavailable
		public static IResponse Unavailable(string message, Exception? exception = null, IEnumerable<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorMessage(message, ErrorType.Unavailable, exception, extensions);
		public static IResponse<TPayload> Unavailable<TPayload>(
			string message,
			TPayload payload,
			Exception? exception = null,
			IEnumerable<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorPayload<TPayload>(payload, message, ErrorType.Unavailable, exception, extensions);
		
		// Timeout
		public static IResponse Timeout(string message, Exception? exception = null, IEnumerable<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorMessage(message, ErrorType.Timeout, exception, extensions);
		public static IResponse<TPayload> Timeout<TPayload>(
			string message,
			TPayload payload,
			Exception? exception = null,
			IEnumerable<(string Property, object? Value)>? extensions = null)
			=> Response.ErrorPayload<TPayload>(payload, message, ErrorType.Timeout, exception, extensions);
		
	}

	extension(IResponse me)
	{
		public bool IsErrorType(object type) => me.ErrorType?.Equals(type) == true;
		public bool IsNotFound() => me.IsErrorType(ErrorType.NotFound);
		public bool IsPermissionDenied() => me.IsErrorType(ErrorType.PermissionDenied);
		public bool IsInvalidData() => me.IsErrorType(ErrorType.InvalidData);
		public bool IsConflict() => me.IsErrorType(ErrorType.Conflict);
		public bool IsCritical() => me.IsErrorType(ErrorType.Critical);
		public bool IsNotSupported() => me.IsErrorType(ErrorType.NotSupported);
		public bool IsUnavailable() => me.IsErrorType(ErrorType.Unavailable);
		public bool IsTimeout() => me.IsErrorType(ErrorType.Timeout);
	}
}

[JsonConverter(typeof(JsonStringEnumConverter))]
public enum ErrorType
{
	NotFound,
	PermissionDenied,
	InvalidData,
	Conflict,
	Critical,
	NotSupported,
	Unavailable,
	Timeout
}