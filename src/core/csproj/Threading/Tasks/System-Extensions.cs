using Fuxion.Threading.Tasks;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace System.Threading.Tasks
{
	public static class Extensions
	{
		public static void Cancel(this Task task, bool throwExceptionIfNotRunning = true)
		{
			var entry = TaskManager.SearchEntry(task, throwExceptionIfNotRunning);
			if (entry != null)
				entry.Cancel();
		}
		public static void CancelAndWait(this Task task, TimeSpan timeout = default(TimeSpan), bool throwExceptionIfNotRunning = true) => new[] { task }.CancelAndWait(timeout, throwExceptionIfNotRunning);
		public static void CancelAndWait(this IEnumerable<Task> me, TimeSpan timeout = default(TimeSpan), bool throwExceptionIfNotRunning = true)
		{
			foreach (var task in me)
				task.Cancel(throwExceptionIfNotRunning);
			try
			{
				if (timeout != default(TimeSpan))
					Task.WaitAll(me.Where(t => t != null && !t.IsCanceled).ToArray(), timeout);
				else
					Task.WaitAll(me.Where(t => t != null && !t.IsCanceled).ToArray());
			}
			// If task was cancelled, nothing happens
			catch (Exception ex) when (ex is TaskCanceledException || ex is AggregateException aex && aex.Flatten().InnerException is TaskCanceledException) { }
		}
		public static void OnCancelRequested(this Task task, Action action) => TaskManager.SearchEntry(task, true).CancelRequested += (s, e) => action();
		public static Task OnCancel(this Task task, Action action) => task.ContinueWith(t => action(), TaskContinuationOptions.OnlyOnCanceled);
		public static Task OnSuccess(this Task task, Action action) => task.ContinueWith(t => action(), TaskContinuationOptions.OnlyOnRanToCompletion);
		public static Task OnFaulted(this Task task, Action<AggregateException> action) => task.ContinueWith(t => action(t.Exception), TaskContinuationOptions.OnlyOnFaulted);
		public static bool IsCancellationRequested(this Task task, bool throwExceptionIfNotRunning = false)
		{
			var entry = TaskManager.SearchEntry(task, throwExceptionIfNotRunning);
			if (entry != null)
			{
				return entry.IsCancellationRequested;
			}
			else
				if (throwExceptionIfNotRunning) throw new ArgumentException("IsCancellationRequested: La tarea no esta administrada por el TaskManager." + task.CreationOptions.ToString());
			else return false;
		}
		public static CancellationToken? GetCancellationToken(this Task task, bool throwExceptionIfNotRunning = false)
		{
			var entry = TaskManager.SearchEntry(task, throwExceptionIfNotRunning);
			return entry?.CancellationTokenSource.Token;
		}
		public static bool Sleep(this Task task, TimeSpan timeout, bool rethrowException = false)
		{
			try
			{
				// Share the token with Delay method to break the operation if task will canceled
				Task.Delay(timeout, task.GetCancellationToken(true).Value).Wait();
				return true;
			}
			// If task was cancelled, nothing happens
			catch (Exception ex) when (ex is TaskCanceledException || ex is AggregateException aex && aex.Flatten().InnerException is TaskCanceledException)
			{
				if (rethrowException)
					throw ex is AggregateException aex2 && aex2.Flatten().InnerException is TaskCanceledException tce ? tce : ex;
				return false;
			}
		}
	}
}
